[
    {
      "labNumber": "1",
      "titlePage": "Використання рекурсії для організації повторювальних процесів",
      "meta": "Сформувати декларативне мислення в галузі програмування завдяки використанню чистих функцій, рекурсій замість циклів, запобіганню даних, що змінюються. Опанувати застосування рекурсивних функцій для обчислювальних процесів.",
      "taskCondition": "Написати процедури, що обчислюють задану функцію за допомогою рекурсивного процесу. Продемонструвати застосування звичайної та хвостової рекурсії. ",
      "tasks" : [
        "3.1. Ввести з клавіатури два натуральних числа n та m. Розрахувати значення функції Аккермана A(m, n) та глибини рекурсії, використовуючи рекурентне співвідношення: Визначити глибину рекурсії. Контрольний тест: А(2, 2) = 7.",
        "3.2 Увести з клавіатури натуральне число n >1. Вивести всі прості дільники цього числа в  порядку неспадання з урахуванням кратності. Алгоритм повинен мати складність O (√n).  Контрольний тест: введено число 18, отриманий результат: 2 3 3."
      ],
      "decisionForIDE": "Було обрано DrRacket як середовище для компілювання коду, а також мову Scheme - які були запропоновані викладачем як найкращий варіант, тому і використовуються в лабораторній.",
      "codes" : [
        "(define depth 0)\n(define (ackerman m n)\n  (set! depth (+ depth 1)) ; збільшуємо глибину рекурсії на 1\n  (cond ((= m 0) (+ n 1)) ; коли m = 0, додаємо 1 до n\n        ((= n 0) (ackerman (- m 1) 1)) ; коли n = 0, рекурсивно викликаємо з (m - 1, 1)\n        (else (ackerman (- m 1) (ackerman m (- n 1)))))) ; рекурсивний виклик з m - 1 та рекурсивним викликом з n - 1\n\n(display \"Input m: \")\n(define m (read))\n(display \"Input n: \")\n(define n (read))\n\n(let ((result (ackerman m n)))\n  (newline)\n  (display \"Result \")\n  (display result)\n  (newline)\n  (display \"Recursion Depth: \")\n  (display depth) ; виводимо глибину рекурсії\n  (newline))",
        "(define (find-prime-divisors n)\n  ;; Функція is-prime перевіряє, чи є число k простим.\n  (define (is-prime k)\n    (define (iter div)\n      (cond ((<= div 1) #t)           ; Якщо div <= 1, то число є простим.\n            ((= (remainder k div) 0) #f)  ; Якщо k ділиться на div, то число не є простим.\n            (else (iter (- div 1)))))  ; Інакше перевіряємо наступний потенційний дільник.\n\n    ;; Якщо k менше за 2, то воно не є простим числом.\n    (if (< k 2) #f (iter (floor (sqrt k)))))\n\n  ;; Функція helper визначає прості дільники числа n.\n  (define (helper k divisor result)\n    (cond ((<= k 1) (reverse result))  ; Якщо k стає менше або дорівнює 1, повертаємо список результату.\n          ((and (is-prime divisor) (= (remainder k divisor) 0))\n           (helper (/ k divisor) divisor (cons divisor result)))  ; Якщо divisor - простий дільник k, додаємо його до результату та рекурсивно викликаємо з новими значеннями.\n          (else (helper k (+ divisor 1) result))))  ; Інакше перевіряємо наступний можливий дільник.\n\n  (if (<= n 1)\n      '()  ; Якщо n менше або дорівнює 1, немає простих дільників, повертаємо порожній список.\n      (helper n 2 '())))  ; Інакше запускаємо пошук простих дільників, починаючи з 2.\n\n(display \"Input n (>1): \")\n(define n (read))\n(display \"Prime Divisors: \")\n(display (find-prime-divisors n))"
      ],
      "result" : [
        "src\\app\\data\\lab1\\1.png",
        "src\\app\\data\\lab1\\2.png"
      ],
      "summary": "В результаті виконаної роботи було вирішено дві предаствлені задачі за варіантом 3. Висновком даної роботи можна зробити у відмінности функціональної мови програмування від інших мов. А саме його принцип роботи та логіка. Хоча у загалом вони схожі є свої нюанси які спонукають на зміну звичного методу мислення на новий. Також було дуже незвичним необхідність постійного використання дужок - це я би зазначила як недолік мови Scheme через свою надмірність в кінечному рахунку. Але уцілому мова сподобалась так як попередно був невеликий досвід з мовою Haskel і саме Scheme здається більш простою функціональною мовою програмування та быльш зрозумілою. Щодо отриманих результатів то вони були прийняті віними завдяки допоміжним значенням з завдання де були представлені правильні відповіді від певних параметрів. Так як вони збігаються то результат вважається вірним."
    },
    {
      "labNumber": "2",
      "titlePage": "Рекурентні співвідношення для тригонометричних, експоненціальних функцій та ланцюгові дроби",
      "meta": "Опанувати теоретичні основи застосування рекурентних співвідношень для обчислення тригонометричних, експоненціальних, степеневих функцій та розробити програми функціональними мовам програмування для обчислення їх значень",
      "taskCondition": "1. Написати процедури, що обчислюють задану функцію за допомогою рекурентних послідовностей, розвинувши її у ряд Маклорена (або Тейлора).\n2. Параметр функції має змінюватися від заданого в процесі виклику мінімального значення до максимального значення із певним кроком.\n3. Розвинення функції в ряд здійснювати із заданою точністю. Точність розрахунку задавати в діапазоні від 10^-2 до 10^-6.\n4. Для розвинення функції у ряд Маклорена (або Тейлора) створити власну функцію, яка розраховує суму ряду за рекурентним співвідношенням.\n5. Значення функції tg(x) обчислювати через функції sin(x) та cos(x).\n6. Визначити похибку обчислення наближених значень функції як різницю абсолютних значень наближеного обчислення та стандартного значення \nфункції.\n7. Стандартне значення функції обчислювати за допомогою бібліотечних математичних функцій.",
      "tasks" : [
        "3.1. Обчислити значення функції у, розвинувши функцію е-х у ряд Тейлора. Аргумент х змінюється від -2 до 2 з кроком 0.5. Визначити похибку.",
        "3.2. Обчислити нескінчений ланцюговий дріб, задавши значення точності при виклику функції. Ланцюговий дріб виражає число π."
      ],
      "decisionForIDE": "Було обрано DrRacket як середовище для компілювання коду, а також мову Scheme - які були запропоновані викладачем як найкращий варіант, тому і використовуються в лабораторній.",
      "codes" : [
        "(;; Yeremenko, IPZ-44, #3\n\n;; Ця функція обчислює факторіал числа n.\n(define (factorial n)\n  (if (= n 0)\n      1\n      (* n (factorial (- n 1)))))\n\n;; Ця функція апроксимує e^(-x) використовуючи ряд Тейлора.\n(define (e-to-the-minus-x x acc)\n  (define (helper x k sign sum prev-sum)\n    (let ((term (* sign (/ (expt x k) (factorial k)))))\n      (if (and (> k 0) (<= (abs (- sum prev-sum)) acc))\n           sum\n          (helper x (+ k 1.0) (- sign) (+ sum term) sum))))\n  (helper x 0 1 0 0))\n\n;; Ця функція обчислює y(x) в залежності від діапазону значень x.\n(define (compute-y x accuracy)\n  (cond ((and (>= x 0) (<= x 2)) (+ (e-to-the-minus-x x accuracy) (e-to-the-minus-x (* 2 x) accuracy)))\n        ((> x 1) (/ 1 (e-to-the-minus-x (+ x 5) accuracy)))\n        (else #f))) ; не визначено\n\n;; Ця функція обчислює реальне значення y(x) без використання апроксимації.\n(define (real-y x)\n  (cond ((and (>= x 0) (<= x 2)) (+ (exp (- x)) (exp (- (* 2 x))))\n        ((> x 1) (/ 1 (exp (+ x 5))))\n        (else #f))) ; не визначено\n\n;; Ця функція виводить порівняння апроксимованого та реального значення y(x) для діапазону значень x.\n(define (compute-and-display accuracy)\n  (let loop ((x -2))\n    (if (<= x 2)\n        (let ((approximated (compute-y x accuracy))\n              (real-result (real-y x)))\n          (cond ((not approximated)\n                 (begin\n                   (display \"x: \")\n                   (display x)\n                   (display \", Функція не визначена\")\n                   (newline)))\n                (else\n                 (begin\n                   (display \"x: \")\n                   (display x)\n                   (display \", Approximated: \")\n                   (display approximated)\n                   (display \", Real: \")\n                   (display real-result)\n                   (display \", Error: \")\n                   (display (abs (- approximated real-result)))\n                   (newline))))\n          (loop (+ x 0.5))))))\n\n\n(display \"    X ,                  Y,              real Y,                Delta\")\n(newline)\n; Викликаємо функцію для виводу результатів:\n(compute-and-display 0.001))",
        "; Yeremenko, IPZ-44, #3 ;\nОбчислення наближеного значення π через безкінечний дріб.\n(define (continued-fraction n max-depth)\n  ;; Функція для обчислення дробу рекурсивно.\n  (if (<= max-depth 0) 0\n      (/ (expt n 2.0) (+ 6.0 (continued-fraction (+ n 1) (- max-depth 1))))))\n; Основна функція для обчислення π з заданою точністю.\n(define (calculate-pi precision)\n  ;; Визначаємо глибину рекурсії на основі точності.\n  (let ((max-depth (* 100 (/ 1 precision))))\n    (+ 3.0 (continued-fraction 1 max-depth))))\n; Функція для обчислення різниці між обчисленим та стандартним значенням π.\n(define (calculate-error precision) (- (calculate-pi precision) pi))\n; Головна процедура, яка виконує виведення результатів.\n(define (main)\n  (let* ((precision 1e-2)\n         (calculated-pi (calculate-pi precision))\n         (error (calculate-error precision)))\n    (display \"Calculated pi: \")\n    (display calculated-pi)\n    (newline)\n    (display \"Real pi: \")\n    (display pi)\n    (newline)\n    (display \"Error: \")\n    (display error)))\n; Визначаємо стандартне значення π для обчислення помилки.\n(define pi 3.141592653589793)\n(main)"
      ],
      "result" : [
        "assets/images/lab2/1.png",
        "assets/images/lab2/2.png"
      ],
      "summary": "Аналіз правильності результатів: \n\nУ кожному завданні було перевірено отримані значення з обрахованими через бібліотеки тому вони можуть вважатис достовірними.\n\nПід час виконання лабораторної роботи було опрацьовано вирішення певних математичних задач у коді.\nЯк висновок цієї роботи можна зробтити те що математичні вирази можна замінити своїми створеними функціями які будуть обраховувати до \nзаданої точності, але чим більша вказана точність тим довше буде обраховуватись результат, або і в загалі може бути перенакопичення буферу. \nТому можно сказати що набагато легше і практичніше використовувати готові бібліотеки для математичних задач."
    },
    {
      "labNumber": "3",
      "titlePage": "Форми lambda та let, вираз присвоєння set! для розв’язання нелінійних рівнянь та чисельного інтегрування функцій",
      "taskCondition": "1. Написати процедури, що знаходять корені нелінійних рівнянь, використовуючи форми lambda, let, set!\n2. Написати процедури, що обчислюють інтеграл функції за формулами прямокутників, трапецій, Сімпсона (парабол)",
      "tasks" : [
        "2.1 Знайти корені нелінійного рівняння виду x = ln(x)+2. Пошук наближеного значення хоча б одного кореня рівняння f(x) = 0 на відрізку [a; b] здійснювати методами перебору та дотичних. Значення a, b інтервалу вибрати самостійно. Порівняти результати розв’язків двома методами",
        "2.2 Якщо f(х) - функція, а dx - деяке мале число, то згладжена версія f(х) є функція, значення якої в точці x є середнє між f (x - dx), f (x) і f (x + dx). Напишіть процедуру, яка в якості параметрів приймає Функцію задати самостійно, яка обчислює f(х), і повертає процедуру, яка обчислює згладжену версію f(х). Функцію задати самостійно."
      ],
      "decisionForIDE": "Було обрано DrRacket як середовище для компілювання коду, а також мову Scheme - які були запропоновані викладачем як найкращий варіант, тому і використовуються в лабораторній.",
      "codes" : [
        ";; Yeremenko, IPZ-44, #2\n;; функція f(x) = ln(x) + 2 - x\n(define f\n  (lambda (x)\n    (- (+ (log x) 2) x)))\n\n;; похідна функції\n(define df\n  (lambda (x)\n    (- (/ 1.0 x) 1)))\n\n;; Метод перебору\n(define (brute-force-method a b step)\n  (let loop ((x a))  ;; починаємо із x = a\n    (cond\n      ;; корені не знайдені\n      ((> x b) #f)\n      ;; Якщо значення функції f(x) близько до 0 (із заданою точністю), тоді повертаємо x як корінь\n      ((< (abs (f x)) 0.0001) x)\n      ;; збільшення x на заданий крок\n      (else (loop (+ x step))))))\n\n;; Метод Ньютона\n(define (newton-method x0)\n  (let loop ((x x0))\n    (let ((next-x (- x (/ (f x) (df x)))))\n      ;; Якщо різниця між поточним та наступним наближенням мала, повертаємо next-x як корінь\n      (if (< (abs (- x next-x)) 0.001)\n          next-x\n          ;; В іншому випадку продовжуємо ітерації із новим наближенням\n          (loop next-x)))))\n\n(define a 1)\n(define b 10)\n\n;; Виводимо корінь, знайдений методом перебору\n(display 'Root using Brute Force: ')\n(display (brute-force-method a b 0.0001))\n(newline)\n\n;; Виводимо корінь, знайдений методом Ньютона, починаючи із середини інтервалу\n(display 'Root using Newton's Method: ')\n(display (newton-method (/ (+ a b) 2)))\n(newline)",
        ";; Yeremenko, IPZ-44, #2\n;; \"згладжена\" версію функції f.\n;; f(x-dx), f(x) та f(x+dx).\n(define (smooth f dx)\n  (lambda (x)\n    (/ (+ (f (- x dx)) (f x) (f (+ x dx))) 3)))\n\n;; Тестова функція: f(x) = x^2\n(define (f x)\n  (* x x))\n\n;; метод прямокутників\n(define (integral-rectangle f a b n)\n  (let ((h (/ (- b a) n)))\n    (let loop ((i 0) (sum 0))\n      (if (= i n)\n          (* h sum)\n          (loop (+ i 1) (+ sum (f (+ a (* i h)))))))))\n\n;; метод трапецій\n(define (integral-trapezoid f a b n)\n  (let ((h (/ (- b a) n)))\n    (let loop ((i 0) (sum 0))\n      (if (= i n)\n          (* h (/ (+ (f a) (f b) (* 2 sum)) 2))\n          (loop (+ i 1) (+ sum (f (+ a (* i h)))))))))\n\n;; метод Сімпсона\n(define (integral-simpson f a b n)\n  (if (odd? n)\n      (error \"n must be even for Simpson's rule!\")\n      (let ((h (/ (- b a) n)))\n        (let loop ((i 1) (sum 0))\n          (cond\n            ((= i n) (* h (/ sum 3)))\n            ((odd? i) (loop (+ i 1) (+ sum (* 4 (f (+ a (* i h)))))))\n            (else (loop (+ i 1) (+ sum (* 2 (f (+ a (* i h))))))))))))\n\n(define smooth-f (smooth f 0.01))\n\n(display \"Integral using Rectangle method: \")\n(display (integral-rectangle smooth-f 0 1 1000))\n(newline)\n\n(display \"Integral using Trapezoid method: \")\n(display (integral-trapezoid smooth-f 0 1 1000))\n(newline)\n\n(display \"Integral using Simpson's method: \")\n(display (integral-simpson smooth-f 0 1 1000))\n(newline)"
      ],
      "result" : [
        "assets/images/lab3/1.png",
        "assets/images/lab3/2.png"
      ],
      "summary": "Аналіз правильності результатів: \n\nРезультати завдань були звірені з розрахунками на спеціальних сервісах в інтернеті і саме щодо точності у першому завданні можна сказати що друге обрахування методом ньютона \nбільш точне. Що стосується другого завдання то саме для обраної функції найкращим методом є саме метод Симпсона. Але узагалом вони всі дають точність приблизно до 4 знака після \nкоми тому можна вважати однаково точними. \n\nПід час виконання лабораторної роботи було опрацьовано чисельне інтегрування за методами перебору, нютона, прямокутників, трапецій та симпсона.\nЯк висновок цієї роботи можна зробтити те що чисельні методи досить точно та швидко можуть бути вирішені в коді Схем\nВарто зазначити що з першого завдання метод ньютона був більш точним, та з першого разу знайшов результат. Він виявився більш зручним бо треба задати довільну точку і воно у будь \nякому разі знайде результат, метод перебору дуже залежить меж бо якщо буде точка за межами він його просто не знайде, а також дуже важлива точність, бо якщо вона буде недостатньою \nкод просто пройде повс рішення і виведе що вірного рішення нема \nЩодо другого завдання то воно було вирішено досить успішно з усіма запропонованими методами, але найточнішим виявився метод Сімпсона"
    },
    {
      "labNumber": "4",
      "titlePage": "Програмування списків мовами функціонального програмування",
      "taskCondition": "1. Написати процедури, що створюють список, модифікують його, здійснюють пошук та упорядкування значень.\n2. Написати процедури, що моделюють бізнес-процеси в компаніях та за допомогою різних сервісів. Бізнес-процеси подати у вигляді списків",
      "tasks" : [
        "2.1 Створити список парних натуральних чисел (натуральні числа >=1), задавши їх кількість./nВивести створений список. Виконати такі операції:/na) Додати елементи на початок списку. Кількість доданих елементів задається;/nb) Здійснити пошук заданого елемента та визначення позиції його в списку, у випадку /nвідсутності елемента вивести відповідне повідомлення;/nc) підрахувати кількість елементів, значення яких в заданому діапазоні.",
        "2.2 Написати код, що моделює роботу планувальника процесів в операційній системі./nНові процеси знаходяться у вхідній черзі і очікують звільнення ресурсу — адресного простору основної пам'яті./nГотові до виконання процеси розташовуються в основній пам'яті і зв'язані чергою готових процесів./nПроцеси в цій черзі чекають на отримання процесорного часу./nПроцес у стані чекання завершення операції введення/виведення знаходиться в одній з черг до пристроїв уведення/виведення./nПід час виконання вказівник процесу мігрує між різними чергами під управлінням програми-планувальник, яка вирішує,/nякий із процесів, що знаходяться в черзі готових процесів, повинен бути переданий на виконання CPU./nВивести на екран черги процесів та сценарій їх міграції."
      ],
      "decisionForIDE": "Було обрано DrRacket як середовище для компілювання коду, а також мову Scheme - які були запропоновані викладачем як найкращий варіант, тому і використовуються в лабораторній.",
      "codes": [
        ";; Yeremenko, IPZ-44, #2\n;; Створити список парних натуральних чисел\n(define (create-even-list n)\n  (let loop ((i 1) (res '()))\n    (if (> i n)\n        (reverse res)\n        (loop (+ i 1) (cons (* i 2) res)))))\n\n;; Додати елементи на початок списку\n(define (prepend-elements lst count)\n  (let loop ((i 1) (res lst))\n    (if (> i count)\n        res\n        (loop (+ i 1) (cons (* i 2) res)))))\n\n;; Здійснити пошук заданого елемента\n(define (find-element lst el)\n  (let loop ((lst lst) (pos 1))\n    (cond ((null? lst) \"Element not found\")\n          ((= (car lst) el) (string-append \"Element found at position: \" (number->string pos)))\n          (else (loop (cdr lst) (+ pos 1))))))\n\n;; Підрахувати кількість елементів у діапазоні\n(define (count-elements-in-range lst low high)\n  (define (helper lst count)\n    (if (null? lst)\n        count\n        (let ((item (car lst)))\n          (helper (cdr lst)\n                  (if (and (>= item low) (<= item high))\n                      (+ count 1)\n                      count)))))\n  (helper lst 0))\n\n\n(define (main)\n  (display \"Enter the number of even natural numbers: \")\n  (let ((n (read)))\n    (let ((lst (create-even-list n)))\n      (display \"Generated list: \")\n      (display lst)\n      (newline)\n\n      (display \"Enter the number of elements to prepend: \")\n      (let ((count (read)))\n        (set! lst (prepend-elements lst count))\n        (display \"Modified list: \")\n        (display lst)\n        (newline))\n\n      (display \"Enter an element to find: \")\n      (let ((el (read)))\n        (display (find-element lst el))\n        (newline))\n\n      (display \"Enter the low end of the range: \")\n      (let ((low (read)))\n        (display \"Enter the high end of the range: \")\n        (let ((high (read)))\n          (display (string-append \"Number of elements in the range: \" (number->string (count-elements-in-range lst low high))))\n          (newline))))))\n\n(main)",
        ";; Yeremenko, IPZ-44, #2\n(define new-process-queue '())\n(define ready-queue '())\n(define io-queue '())\n\n(define (make-process id state)\n  (list (cons 'id id) (cons 'state state)))\n\n;; get id of process\n(define (process-id proc)\n  (cdr (assoc 'id proc))) ;; cdr gets last value\n\n(define (process-state proc)\n  (cdr (assoc 'state proc)))\n\n(define (set-process-state! proc new-state) ;; ! - for mutaded func\n  (set-cdr! (assoc 'state proc) new-state)) ;; change last elem - state\n\n(define (add-new-process id)\n  (set! new-process-queue (append new-process-queue (list (make-process id 'new)))))\n\n(define (print-queues)\n  (display \"New Processes: \") (display new-process-queue) (newline)\n  (display \"Ready Queue: \") (display ready-queue) (newline)\n  (display \"-------------------------------\") (newline))\n\n(define (scheduler)\n  (display \"Before scheduling:\") (newline)\n  (print-queues)\n\n  ;; Переносимо нові процеси до черги готовності\n  (set! ready-queue (append ready-queue new-process-queue))\n  (set! new-process-queue '())\n\n  (display \"After moving new processes to ready queue:\") (newline)\n  (print-queues))\n\n(define (main)\n  (display \"Adding new processes...\") (newline)\n  (add-new-process 1)\n  (add-new-process 2)\n  (scheduler)\n\n  (display \"-------------------------------\") (newline)\n  (display \"Setting the first ready process to 'running' state...\") (newline)\n  (set-process-state! (car ready-queue) 'running)\n  (print-queues))\n\n(main)"      
      ],
      "result" : [
        "assets/images/lab4/1.png",
        "assets/images/lab4/2.png"
      ],
      "summary": "Аналіз правильності результатів: \n\nРоботу обох програм було протестовано та перевірено на необхідний результат. Так як не було присутньо математичних завдань додаткова перевірка достовірності вважається неможливою. \n\nПід час виконання лабораторної роботи було опрацьовано задачі в яких використовувались мутуючі функції та які виконують звичайні логічні процесси. Загалом до висновку роботи можно \nвіднести саме друге завдання яке краще дає змогу зрозуміти роботу процессора при її відтворенні через процесси. Щодо першой задачі то вона легка задача для більшого розуміння\n різних команд мови схем, тому вона надає саме більше інформації з різних команд мови Схем."
    },
    {
      "labNumber": "5",
      "titlePage": "Обробка раціональних та комплексних чисел мовами функціонального програмування",
      "taskCondition": "1. Написати процедури, що обробляють раціональні числа (працюють з дробами), які подати у вигляді чисельника і знаменника . \n2. Написати процедури, що обробляють комплексні числа, які слід подати в декартовому (алгебраїчному) (z = a + i×b) та/або полярному \n(z=√(a^2+b^2)(cosφ + i×sin(φ))) зображенні.\n3. Не використовувати бібліотеки та готові функції із IDE",
      "tasks" : [
        "2.1 Знайти суму чотирьох дробив 1/a + 1/b + 1/c + 1/d де a, b, c, d – непарні натуральні числа. Якщо сума цих дробив дорівнює 1, вивести повідомлення “YES”, інакше “NO”. Для розв’язання \nзадачі написати процедуру приведення дробив до спільного знаменника.",
        "2.2 Створити список з комплексних чисел, заданих в алгебраїчній формі в декартових координатах z=a + ib. Створити новий список, елементи якого є комплексні числа, переведені \nз декартових координат у полярні. Комплексне число в полярних координатах складається з модуля  | z |= sqrt(a^2 + b^2) та аргументу arg z = arctg(a/b) . Надрукувати новий список."
      ],
      "decisionForIDE": "Було обрано DrRacket як середовище для компілювання коду, а також мову Scheme - які були запропоновані викладачем як найкращий варіант, тому і використовуються в лабораторній.",
      "codes": [
        ";; Yeremenko, IPZ-44, #2\n(define (my-gcd a b)\n  (if (= b 0)\n      a\n      (my-gcd b (modulo a b))))\n\n(define (my-lcm a b)\n  (if (or (= a 0) (= b 0))\n      0\n      (/ (abs (* a b)) (my-gcd a b))))\n\n(define (lcm-for-list lst)\n  (define (iter l rest)\n    (if (null? rest)\n        l\n        (iter (my-lcm l (car rest)) (cdr rest))))\n  (iter 1 lst))\n\n(define (display-fraction numerator denominator)\n  (display \"(\")\n  (display numerator)\n  (display \"/\")\n  (display denominator)\n  (display \")\"))\n\n(define (add-fractions a b c d)\n  (let* ((nums (list a b c d))\n         (denom-lcm (lcm-for-list nums))\n         (fractions (map (lambda (x) (list (/ denom-lcm x) denom-lcm)) nums))\n         (numerator-sum (apply + (map car fractions))))\n    ;; original fractions\n    (display \"1/\") (display a) (display \" + \")\n    (display \"1/\") (display b) (display \" + \")\n    (display \"1/\") (display c) (display \" + \")\n    (display \"1/\") (display d) (newline)\n    ;; adjusted fractions with common denominator\n    (for-each (lambda (frac)\n                (display-fraction (car frac) (cadr frac))\n                (display \" + \"))\n              fractions)\n    (display \" = \")\n    (display-fraction numerator-sum denom-lcm)\n    (newline)\n    (if (= numerator-sum denom-lcm)\n        (begin\n          (display \"YES\"))\n        (begin\n          (display \"NO\")))))\n\n(add-fractions 1 3 5 7)\n;(add-fractions 4 4 4 4)",
        ";; Yeremenko, IPZ-44, #2\n(define (square x)\n  (* x x))\n\n(define (complex-modulus a b)\n  (sqrt (+ (square a) (square b))))\n\n(define (complex-argument a b)\n  (if (and (= a 0) (= b 0))\n      0 ;;  0 + 0i is undefined; so return 0\n      (atan b a)))\n\n(define (convert-to-polar complex-list)\n  (map (lambda (complex-number)\n         (let ((a (car complex-number))\n               (b (cadr complex-number)))\n           (cons (complex-modulus a b)\n                 (complex-argument a b))))\n       complex-list))\n\n(define (print-complex-list lst)\n  (if (null? lst)\n      (newline)\n      (begin\n        (display \"|z|: \")\n        (display (car (car lst)))\n        (display \", arg(z): \")\n        (display (cdr (car lst)))\n        (newline)\n        (print-complex-list (cdr lst)))))\n\n;; just for input list\n(define (print-complex-numbers lst)\n  (display \"[\")\n  (define (print-pair pair)\n    (display \"(\")\n    (display (car pair))\n    (display \",\")\n    (display (cadr pair))\n    (display \")\"))\n  (define (iter l)\n    (if (not (null? l))\n        (begin\n          (print-pair (car l))\n          (if (not (null? (cdr l)))\n              (display \",\"))\n          (iter (cdr l)))))\n  (iter lst)\n  (display \"]\")\n  (newline))\n\n;; our list\n(define complex-numbers-list '((3 4) (1 1) (-1 1) (0 1)))\n\n;; printing list\n(print-complex-numbers complex-numbers-list)\n\n;; converting list\n(define polar-coordinates-list (convert-to-polar complex-numbers-list))\n\n;; printing new list\n(print-complex-list polar-coordinates-list)\n\n\n(define (complex-list-to-string lst)\n  (define (iter l acc)\n    (if (null? l)\n        acc\n        (iter (cdr l)\n              (string-append acc\n                             \"(|z|: \"\n                             (number->string (car (car l)))\n                             \", arg(z): \"\n                             (number->string (cdr (car l)))\n                             \") \"))))\n  (iter lst \"\"))\n\n(define polar-coordinates-string (complex-list-to-string polar-coordinates-list))\n\n;; printing polar list\n(display polar-coordinates-string)"
      ],
      "result" : [
        "assets/images/lab5/1.png",
        "assets/images/lab5/2.png"
      ],
      "summary": "Аналіз правильності результатів: \n\nПравильність розрахунків першої програми було виконано самостійно перерахувавши найменший спільний дільник. Перевірку того що воно виводить \nрезультат ТАК якщо дріб дорівнює 1 було проведено одразу у коді через додавання чотірьох дробів 1/4. Другий код було перевірено завдяки онлайн калькуляторам і вважається вірним. \n\nПід час виконання лабораторної роботи було опрацьовано задачі з рахуванням дробів та комплексних чисел. Загалом можна сказати що певних \nскладнощів з цим не виникло і тому можна сказати що дане обрахування було зручним. Також під час цієї роботи було виявлено функцію \nпослідовного присвоювання значень,що було досить зручним у використанні та розумінні."
    }
    ,
    {
      "labNumber": "6",
      "titlePage": "Обробка структур типу векторів і матриць, стеків та черг мовами функціонального програмування",
      "taskCondition": "1. Написати процедури, що обробляють вектори відповідно до правил векторної \nалгебри з індексацією елементів вектору та прямим доступом до елементів\n2. Написати процедури, що обробляють черги відповідно до правил FIFO (перший \nприйшов — перший пішов) та стеків за правилами LIFO (останній прийшов -\nперший пішов)",
      "tasks" : [
        "2.1 Створити вектор. Обчислити суму елементів між максимальним та мінімальними значеннями вектору. Вивести на екран максимальний, мінімальний елементи масиву, їх індекси та шукану суму елементів",
        "2.2 Створити чергу з чисел. Розрахувати їх середнє арифметичне та середнє геометричне. Надрукувати вміст черги, визначити кількість її елементів."
      ],
      "decisionForIDE": "Було обрано DrRacket як середовище для компілювання коду, а також мову Scheme - які були запропоновані викладачем як найкращий варіант, тому і використовуються в лабораторній.",
      "codes": [
        "; Створення вектора\n(define (create-vector elements)\n  (list->vector elements))\n\n; Знаходження максимального і мінімального елементів та їх індексів\n(define (find-min-max-index vector)\n  (let loop ((min (vector-ref vector 0))\n             (max (vector-ref vector 0))\n             (min-index 0)\n             (max-index 0)\n             (index 1))\n    (if (= index (vector-length vector))\n        (list min max min-index max-index)\n        (let ((current (vector-ref vector index)))\n          (loop (if (< current min) current min)\n                (if (> current max) current max)\n                (if (< current min) index min-index)\n                (if (> current max) index max-index)\n                (+ index 1))))))\n\n; Обчислення суми елементів\n(define (sum-between min-index max-index vector)\n  (let ((start (min min-index max-index))\n        (end (max min-index max-index)))\n    (let loop ((sum 0) (index (+ start 1)))\n      (if (< index end)\n          (loop (+ sum (vector-ref vector index)) (+ index 1))\n          sum))))\n\n; Виведення\n(define (display-vector vector)\n  (define (display-vec-helper index)\n    (if (< index (vector-length vector))\n        (begin\n          (display (vector-ref vector index))\n          (display \" \")\n          (display-vec-helper (+ index 1)))))\n  (display-vec-helper 0))\n\n\n; Основна процедура обробки\n(define (process-vector vector)\n  (let* ((min-max-indexes (find-min-max-index vector))\n         (min (car min-max-indexes))\n         (max (cadr min-max-indexes))\n         (min-index (caddr min-max-indexes))\n         (max-index (cadddr min-max-indexes))\n         (sum (sum-between min-index max-index vector)))\n    (display \"Vector: \")\n    (display-vector vector)\n    (newline)\n    (display \"Min: \") (display min) (display \" at index: \") (display min-index)\n    (newline)\n    (display \"Max: \") (display max) (display \" at index: \") (display max-index)\n    (newline)\n    (display \"Sum between min and max: \") (display sum)\n    (newline)))\n\n(define my-vector (create-vector '(2 0 1 2 4 3)))\n(process-vector my-vector)\n"
        ,        
        "; Створення черги\n(define (create-queue elements)\n  elements)\n\n; Розрахунок середнього арифметичного\n(define (average-arithmetic queue)\n  (/ (apply + queue) (length queue)))\n\n; Розрахунок середнього геометричного\n(define (average-geometric queue)\n  (exp (/ (apply + (map log queue)) (length queue))))\n\n(define (print-queue-info queue)\n  (display \"Queue: \") (display queue) (newline)\n  (display \"Number of elements: \") (display (length queue)) (newline)\n  (display \"Average Arithmetic: \") (display (average-arithmetic queue)) (newline)\n  (display \"Average Geometric: \") (display (average-geometric queue)) (newline))\n\n(define my-queue (create-queue '(1 2 3 4 5)))\n(print-queue-info my-queue)\n"
      ],
      "result" : [
        "assets/images/lab6/1.png",
        "assets/images/lab6/2.png"
      ],
      "summary": "Аналіз правильності результатів: \n\nПравильність розрахунків обох завдань було перевірено самостійно через легкість у розрахунках. У першому завданні легко можна побачити \nправильність виконання на прикладі наданих скріншотів. У другому завданні так само розракунки виявились дуже легкими і можна перевірити за \nскрішотом.\n\nПід час виконання лабораторної роботи було опрацьовано задачі з використанням векторів та черг. Загалом як висновок можна сказати що вектори \nта черги дуже схожі у своєму сенсі, але використовують різні системні команди. Щодо логіки самих завдань то вони подібні до звичайних задач \nз програмування що було лего до розуміння та виконання."
    }
    ,
    {
      "labNumber": "7",
      "titlePage": "Обробка рядків та файлів мовами функціонального програмування",
      "taskCondition": "Написати процедури, що обробляють рядки, які зчитані з текстових файлів. \nРезультати обробки рядків записати до текстових файлів",
      "tasks" : [
        "Записати в текстовий файл n рядків тексту, що задаються програмою на функціональній мові програмування. Зчитати рядки із створеного програмою файлу, вивести їх на екран. \nПорахувати кількість повторень кожної літери в рядках тексту. Замінити задану користувачем літеру в тексті на її порядковий номер в алфавіті. Записати в новий текстовий файл результат обробки тексту"
      ],
      "decisionForIDE": "Було обрано DrRacket як середовище для компілювання коду, а також мову Scheme - які були запропоновані викладачем як найкращий варіант, тому і використовуються в лабораторній.",
      "codes": [
        ";; Yeremenko, IPZ-44, #2\n; Запис рядків\n(define (write-lines-to-file lines filename)\n  (call-with-output-file filename\n    (lambda (output)\n      (for-each (lambda (line)\n                  (write line output)\n                  (newline output))\n                lines))\n    #:exists 'replace))  ; Цей параметр дозволяє перезаписувати існуючі файли\n\n; Читання рядків з файлу\n(define (read-lines-from-file filename)\n  (let ((input (open-input-file filename)))\n    (let loop ((line (read-line-custom input))\n               (lines '()))\n      (if (null? line)\n          (begin (close-input-port input) (reverse lines))\n          (loop (read-line-custom input) (cons line lines))))))\n\n; функція читання\n(define (read-line-custom input)\n  (let loop ((chars '()))\n    (let ((next-char (read-char input)))\n      (cond ((or (eof-object? next-char) (char=? next-char #\\newline))\n             (if (null? chars) '() (list->string (reverse chars))))\n            (else (loop (cons next-char chars)))))))\n\n; Підрахунок повторень літери\n(define (count-letters lines)\n  (let ((counts '()))\n    (letrec ((update-counts (lambda (char)\n       (let ((entry (assoc char counts)))\n        (if entry\n          (set-cdr! entry (+ 1 (cdr entry)))\n           (set! counts (cons (cons char 1) counts)))))))\n      (for-each (lambda (line)\n                  (for-each update-counts (string->list line)))\n                lines))\n    counts))\n\n; Виведення кількості літери\n(define (display-letter-counts counts)\n  (for-each (lambda (count-pair)\n              (display (car count-pair))\n              (display ': ')\n              (display (cdr count-pair))\n              (newline))\n            counts))\n\n; Заміна літери на її порядковий номер\n(define (replace-letter lines letter)\n  (map (lambda (line)\n         (list->string (apply append (map (lambda (char)\n            (if (char=? char letter)\n               (string->list (number->string (+ 1 (- (char->integer char)\n                  (char->integer #\\A)))))\n                (list char)))\n             (string->list line)))))\n       lines))\n\n\n; Обробка тексту\n(define (process-text lines letter-to-replace)\n  (let ((letter-counts (count-letters lines))\n        (replaced-lines (replace-letter lines letter-to-replace)))\n    (display 'Літера: Кількість повторень\\n')\n    (display-letter-counts letter-counts)\n    replaced-lines))\n\n; Головна функція\n(define (main)\n  (let ((lines '(\"Apple is a great fruit.'\n                 \"Always look on the bright side of life.'\n                 \"Artificial intelligence and machine learning.'\n                 \"Astronomy is fascinating.')))\n    (write-lines-to-file lines \"D:\\\\mosha\\\\7semester\\\\ФП\\\\original.txt\")\n    (let ((read-lines (read-lines-from-file \"D:\\\\mosha\\\\7semester\\\\ФП\\\\original.txt\")))\n      (display 'Прочитані рядки:\\n') (display read-lines)\n      (let ((processed-lines (process-text read-lines #\\A)))  ; пр 'A'\n        (write-lines-to-file processed-lines \"D:\\\\mosha\\\\7semester\\\\ФП\\\\processed.txt\"))))\n\n(main)\n"
      ],
        "result" : [
        "assets/images/lab7/1.png",
        "assets/images/lab7/2.png"
      ],
      "summary": "Аналіз правильності результатів: \n\nПравильність виконання була перевірена за результатами редагування текстів та власноруч були пораховані усі символи які порахувала система та \nзначення збіглись тому вважається вірним у виконанні. \n\nПід час виконання лабораторної роботи було опрацьовано завдання з роботой з файлами. Загалом можна сказати що все працює аналогічно до \nзвичайних мов програмування, із нюансів є тільки що Схем не перезаписує автоматично файл і може видавати помилку якщо файл вже існує, \nдля цього треба було додати налаштування обробленя ситуації коли файл вже існує. Також з висновків можна сказати що для перевірки \nсимволів система чутлива до мови, тобто використання англійської літери А та української А буде мати різницю при повертанні, через те що вони \nмають різне кодування. У цілому код виконує заадні вимоги і працює вірно."
    }
  ]
  


  
